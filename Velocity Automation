%% Andrew Comstock VUGIST 06/17/19

%The purpose of this code is to supplemet the velocity
%calculation in calcPropVelClean1, fully automate all processes, and 
%quantify the change in angle from one velocity element to another 
%to create a way to determine the direction of propagation.

%% Finding the average velocity over the path

%xd must already be loaded in the workspace from running calcPropVelClean1

cutoff = .3;
n = 0;
maxdata = xd;
timestep = 1/3;
[length,~]= size(maxdata);

%find the change in x and y between every two points in time
inf_small_velx = diff(maxdata(:,1))/timestep;
inf_small_vely = diff(maxdata(:,2))/timestep;

%throw out the data that represents a 'jump' in the maximum.
for i = 1:(length-1)
    
    if abs(maxdata(i,1)-maxdata(i+1,1))> cutoff*timestep
        inf_small_velx(i) = NaN;
        n = n+1;
    elseif abs(maxdata(i,2)-maxdata(i+1,2))> cutoff*timestep
        inf_small_vely(i) = NaN;
        n=n+1;
    end
  
end
    
inf_small_vel = sqrt(inf_small_velx.^2 + inf_small_vely.^2);
     
v = mean(inf_small_vel,'omitnan');

fprintf('the average speed was %0.6f and the number of jumps was %f\n',v,n)

%% direction calculation
% now we need to find the change in angles, hopefully to determine if the 
%propagation is retrograde or anterograde

angles = atand(inf_small_vely./inf_small_velx);

%condition the data:
for i = 1:(length-1)
    
    %throw out angle measures that correspond to 'jumps' if the slow wave
    %'restarts' we don't want to measure that
    if abs(maxdata(i,1)-maxdata(i+1,1))> cutoff*timestep
        angles(i) = NaN;
        n = n+1;
    elseif abs(maxdata(i,2)-maxdata(i+1,2))> cutoff*timestep
        angles(i) = NaN;
        n=n+1;
    end
    
    %this section fixes the domain issues with the atand function. After
    %this, angles are defined on 0 to 360
    if inf_small_velx(i) <= 0 && inf_small_vely(i) <= 0
        angles(i) = angles(i) + 180;
    elseif inf_small_velx(i) <= 0 && inf_small_vely(i) >= 0
        angles(i) = angles(i) + 180;
    elseif inf_small_velx(i) >= 0 && inf_small_vely(i) <= 0
        angles(i) = angles(i) + 360;
    end
  
end

%throw away the angles that correspond to no movement
good_locations = find(angles);
[siz,~] = size(good_locations);
angles1 = zeros(size(good_locations));
for i = 1:siz
    angles1(i) = angles(good_locations(i));
end

%angles1 contains all the good angles that correspond to normal movement of
%the gastric slow wave.

average_angles = mean(angles1,'omitnan');
fprintf('the average angle is %f degrees from +x\n',average_angles)

%maybe implement a weighted mean. Let the angles that correspond to longer
%paths be weighted higher

fprintf('now calculating the weighted average...\n')
figure
polarscatter(angles.*pi./180,inf_small_vel)
title('velocity distibution over angles')

weighted_average = sum(inf_small_vel.*angles,'omitnan');
weighted_average = weighted_average/sum(inf_small_vel,'omitnan');

fprintf('the weighted average is %f\n',weighted_average)

%for the data set taken on new years eve, 2018, time stamp 540, the
%weighted average gave a better approximation to the observed propagation
%direction. Test other data sets to see what works. Also, we need to
%determine the right number for the cutoff value.
